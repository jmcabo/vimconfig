"Configuraci√≥n VIM Multiplataforma                          vim600:fdm=marker
"Juan Manuel Cabo
"Date: 2008-10-08, 2010-06-07, 2012-12-20, 2013-04-13, 2016-08-12, 2023-08-30, 2024-04-29, 2024-09-06, 2024-09-19

" Espec√≠fico de Windows ------------------------------------------------- {{{1
if has("win32")
    set nocompatible

    "Skip loading vimrc_example.vim, it does weird things (as of 2023):
    "  source $VIMRUNTIME/vimrc_example.vim

    source $VIMRUNTIME/mswin.vim

    "Setear si tenemos cygwin
    "let cygwinpath='h:/cygwin'

    "-----from _vimrc_fabrica90 -----
    " Use the internal diff if available.
    " Otherwise use the special 'diffexpr' for Windows.
    if &diffopt !~# 'internal'
        set diffexpr=MyDiff()
    endif
    function MyDiff()
        let opt = '-a --binary '
        if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
        if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
        let arg1 = v:fname_in
        if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
        let arg1 = substitute(arg1, '!', '\!', 'g')
        let arg2 = v:fname_new
        if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
        let arg2 = substitute(arg2, '!', '\!', 'g')
        let arg3 = v:fname_out
        if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
        let arg3 = substitute(arg3, '!', '\!', 'g')
        if $VIMRUNTIME =~ ' '
            if &sh =~ '\<cmd'
                if empty(&shellxquote)
                    let l:shxq_sav = ''
                    set shellxquote&
                endif
                let cmd = '"' . $VIMRUNTIME . '\diff"'
            else
                let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
            endif
        else
            let cmd = $VIMRUNTIME . '\diff'
        endif
        let cmd = substitute(cmd, '!', '\!', 'g')
        silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
        if exists('l:shxq_sav')
            let &shellxquote=l:shxq_sav
        endif
    endfunction

    if exists('cygwinpath')
        let &grepprg=cygwinpath . '/bin/grep -nH'
    endif

    language english

    let Tlist_Ctags_Cmd='ctags.exe'
endif
" Espec√≠fico de Linux --------------------------------------------------- {{{1
if has("unix")
    if filereadable("$VIMRUNTIME/vimrc-default.vim")
        source $VIMRUNTIME/vimrc-default.vim
    endif

    "Backspace and cursor keys wrap to previous/next line:
    " set backspace=2 whichwrap+=<,>,[,]

    "Ver man pages con ':Man <palabra>'
    runtime ftplugin/man.vim

    set ai
    set cindent
endif
" Added by juanma ------------------------------------------------------- {{{1
" General --------------------------------------------------------------- {{{2
set nocompatible

"Skip loading /usr/share/vim/vim80/defaults.vim, it does weird things:
let skip_defaults_vim=1

"Colores Vim en consola:
if has("win32") || has("win32unix")
    "Use 256 colors in windows console, otherwise the colors are not right:
    let g:JmcDarkForce16ColorsInConsole=0
    "Use black background always in windows:
    let g:JmcDarkUseGreyBackground=0
else
    "Limit to the base 16 colors, so it fallbacks to the 16 colors chosen
    "in Linux Konsole or Yakuake appearance config:
    let g:JmcDarkForce16ColorsInConsole=1
    "Use slight grey background in Linux GUI:
    let g:JmcDarkUseGreyBackground=1
endif
try
    colors jmcdark
catch /^Vim(colorscheme):E185:.*$/
    colors darkblue
endtry

if has("syntax")
    syntax on
endif
set showcmd
set modeline
set modelines=3
let g:secure_modelines_modelines=3
set nobackup
set vb t_vb=
set nowrap
set undolevels=5000
"History length default was 50 (Added 2024-06-12):
set history=1000
"Hacer que al incrementar 07 no pase a 10 con CTRL+A (Added 2024-08-27):
set nrformats-=octal
"Hacer que al incrementar cosas con gui√≥n como fechas no decremente con CTRL+A (Added 2024-09-19):
set nrformats+=unsigned

"Hacer que los comentarios y ifdefs con # no se desidenten solos
inoremap # X#
"Le saco el "0#". El default es: set cinkeys=0{,0},0),:,0#,!^F,o,O,e
set cinkeys=0{,0},0),:,!^F,o,O,e
if has("autocmd")
    " Enable file type detection.
    " Use the default filetype settings, so that mail gets 'tw' set to 72,
    " 'cindent' is on in C files, etc.
    " Also load indent files, to automatically do language-dependent indenting.
    filetype plugin indent on
endif

"Set 'selection', 'selectmode', 'mousemodel' and 'keymodel' for MS-Windows
behave mswin
"Set a fold column (margin) of 2 characters wide.
set fdc=2
"Para que no pida presionar enter (ver hit-enter) y sea m√°s alto el cmdline
set cmdheight=2
" Teclas --------------------------------------------------------------- {{{2
map W :update<CR>

"Cerrar buffer y su ventana:
"map Q :bd<CR>
"Cerrar buffer sin cerrar su ventana (si no hay next cierra todas):
"map Q :bnext \| bdelete#<CR>
"Cerrar buffer sin cerrar ventana (si es el √∫nico, cierra todas):
map Q :Bclose<CR>

"Para mostrar el nombre de la funci√≥n en el statusbar, si se ejecut√≥
"antes el :Tlist
map <F3> :TlistShowTag<CR>
map <F2> :TlistShowPrototype<CR>

"Repetir b√∫squeda con F3,
"Shift-F3 buscar atr√°s, ctrl-F3 limpiar search pattern:
" map <F3> n
" map <C-F3> :let @/=""<CR>
" map <S-F3> N

"Switch buffers with F5,F6. List buffers with F7
map  <F5> :bp!<CR>
imap <F5> <ESC><F5>
map  <F6> :bn!<CR>
imap <F6> <ESC><F6>
map  <F7> :ls<CR>
imap <F7> <ESC><F7>
map <F8> :cn<CR>
map <S-F8> :cp<CR>
"Ctrl-Enter hace nueva l√≠nea y sube a la l√≠nea de arriba
"(ideal para despu√©s de cerrar un brace }.
imap <C-Enter> <C-o>O
"Teclas Quickfix
"compile file with unit tests:
map <F9> :update<CR>:!dmd % dunit.d && ./%:r<CR>
"map <F9> :update<CR>:make<CR>
imap <F9> <ESC><F9>
map  <S-F9> :make clean<CR>
imap <S-F9> <ESC><S-F9>
map  <F10> :update<CR>:!make run<CR>
imap <F10> <ESC><F10>
if has("gui_running")
    if has("win32")
        "Usar F11 adem√°s de F10 (F10 va a menus)
        map  <F11> :update<CR>:!make run<CR>
        imap <F11> <ESC><F11>
    endif
endif
"Ctrl-Tab also switches buffers
map <C-Tab> <F6>
map <C-S-Tab> <F5>
"Ctrl-PageDown and Ctrl-PageUp also switches buffers
map <C-PageDown> <F6>
map <C-PageUp> <F5>
"Ctrl-Up and Ctrl-Down to scroll without moving cursor
nmap <C-Up> <C-y>
nmap <C-Down> <C-e>
imap <C-Up>   <C-x><C-y>
imap <C-Down> <C-x><C-e>
"f and F switches windows (forwards and backwards respectively)
map f <C-w>w
map F <C-W>W
"Fix :E not resolving to :Explore, because conflicting with :ELP that comes with logipat in the newer vimruntime.
"cmap :E<CR> :Ex<CR>
command! -nargs=* -bar -bang -count=0 -complete=dir E Explore <args>
" B√∫squeda ------------------------------------------------------------ {{{2
"Highlight search (hls):
set hlsearch
set ignorecase
set smartcase
set noincsearch
" Tabs ---------------------------------------------------------------- {{{2
set tabstop=4
set shiftwidth=4
"Spaces en lugar de tabs
set expandtab
set softtabstop=4
"Para ver tabs, tipear :set list. Los tabs aparecen >--- y final de linea $
set listchars=eol:$,tab:>-
" QuickFix ------------------------------------------------------------ {{{2
if has("win32")
    "set makeprg=soutmake
    set makeprg=make
    "Para ver el progreso de make mientras ejecuta
    "CYGWIN
    if exists('cygwinpath')
        let &shellpipe='2>&1 | ' . cygwinpath . '/bin/tee'
    endif
    "old setting: set shellpipe=2>&1\ \|\ e:/cygwin/bin/tee
endif
" Explorer Plugin ----------------------------------------------------- {{{2
let g:explSortBy='name'      " Ordenar archivos por nombre
let g:explSuffixesLast=0     " Files matching suffixes sorted normally
let g:explVertical=1         " Cuando es llamado con :Sexplore hace un split vertical
" TagmaBufMgr Plugin -------------------------------------------------- {{{2
let g:TagmaBufMgrMapChjkl = 0     "Para que no overridee Ctrl-j Ctrl-k
let g:TagmaBufMgrMapChjklbuf = 0  "Para que no overridee Ctrl-j Ctrl-k
let g:TagmaBufMgrMapCArrow = 0    "Para que no pise Ctrl-flechitas
let g:TagmaBufMgrLastWindow = 1   "Cerrar vim al cerrar ultimo buffer
" Airline Tabs and Statusbar Plugin ----------------------------------- {{{2
set laststatus=2                                       "Always show statusline even if last window
let g:airline#extensions#tabline#enabled = 1           "Show tabs
let g:airline#extensions#tabline#buffer_nr_show = 1    "Tab buffer number
"let g:airline#extensions#tabline#buffer_idx_mode = 1  "Tab number from 1 to 9 in superscript.

"Show only the filename and extension in tabs (see "filename-modifiers"):
let g:airline#extensions#tabline#fnamemod = ':t'
"On top of that, also show enough parent dirs to differentiate in duplicates:
let g:airline#extensions#tabline#formatter = "unique_tail_improved"

"Theme of statusline and tabline:
"let g:airline_theme="dark"
"let g:airline_theme="kolor"
let g:airline_theme="sol"

"Powerline font symbols:
"let g:airline_powerline_fonts=1
""set encoding=utf-8

"Notes: When more than one tab is open (ej: :tabnew) it switches to VIM's
"native tab mode (instead of showing one buffer per Airline tab, it shows one
"VIM native tab per Airline tab).
"  In tab mode, use keys "gt" to move between tabs. Use :tabclose or :tabc to
"close tabs and go back to buffers mode.


" CtrlP plugin Fuzzy buffer/mru/file finder --------------------------- {{{2
"Possible values: CtrlP, CtrlPBuffer, CtrlPMRU, CtrlPLastMode
"Note: toggle modes with Ctrl up/down or with C-f and C-b:
"      Close the ctrlp window with Ctrl-C
"      Toggle filename only with CTRL-D and toggle regex with CTRL-R
"      Move up or down with arrows or with CTRL-J and CTRL-K
let g:ctrlp_cmd = "CtrlPLastMode"
"Top-to-bottom or bottom-to-top (order of displayed options):
let g:ctrlp_match_window = "order:ttb"


" VMath Sum Numbers In Selection -------------------------------------- {{{2
"One can also pass the selection to 'csvstat' from 'csvkit' like this:
"   1) SHIFT+V and select
"   2) Then run    :'<,'>!csvstat -y0 -H
"      and the selection will be replaced by the stats (mean, median, sum,
"      etc.). The -H is so that it knows that the first line is a number
"      and not a header. The -y0 is for it not to give an error trying
"      to autodetect CSV column separator and quoting chars.
"      If there are multiple columns of numbers, csvstat analyzes all by
"      default, but it can also analyze only one column.
"   3) The one thing that csvstat has that vmath doesn't is the histogram
"      with the median and the number of ocurrences and number of unique
"      values.
"But this VMath plugin does almost exactly the same.
"   1) SHIFT+V or CTRL+V and select a set of numbers.
"   2) Hit the keys  ++  and it will show the stats, and have put them
"      in their respective registers. To paste the average, type "ap
"      To paste the sum type "sp
vmap <expr>  ++  VMATH_YankAndAnalyse()
nmap         ++  vip++


" DiffOrig brought from defaults.vim ---------------------------------- {{{2

"Since I disabled loading of defaults.vim (it does too many weird things),
"I wanted to bring this function which seems useful:

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
" Revert with: ":delcommand DiffOrig".
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif


" Bash shell ---------------------------------------------------------- {{{2
if has("win32")

    if exists('cygwinpath')
        "wdebug:  ctags works with everything commented. delete if these are not
        "         needed for other things:
        "
        "CYGWIN
        let &shell=cygwinpath . '/bin/bash.exe -i'
        set shellcmdflag=-c
        set shellredir=>%s\ 2>&1
        set shellxquote=\"
        set shellslash
    else
        "DJGPP Bash
        "wdebug:  ctags works with everithing commented. delete if these are not
        "         needed for other things:
        "set shell=bash.exe\ -i
        "set shellcmdflag=-c
        "set shellredir=>%s\ 2>&1
        "set shellxquote=\"
        "set shellslash
    endif
endif

" SQL Autocomplete CTRL+C Deshabilitar -------------------------------- {{{2

"Estaba muy pesado que editando archivos .SQL se hace una pausa cada vez
"que uno sale del modo insert con CTRL+C. Muy hincha. Resulta que hay una
"manera en Vim de que se conecte a la base de datos y que autocomplete el .SQL
"con nombres de tablas reales y cosas as√≠. No me interesa.
"
"Ver, greppear omni:
"   /usr/share/vim/vim82/ftplugin/sql.vim
"Y ver, greppear omni:
"   :help ft_sql
"Con esto se ven los mappings actuales al editar un ".sql":
"   :verbose imap <buffer> <C-c>
"Por ejemplo, se ve que CTRL+C+t autocompleta tablas.
"Igual, al intentar hacer <C-C>t tira este error:
"   SQLComplete:The dbext plugin must be loaded for dynamic SQL completion
"

"El default era esto con CTRL+C:
    "let g:ftplugin_sql_omni_key = '<C-C>'
"Se puede poner a CTRL+space:
let g:ftplugin_sql_omni_key = '<C-Space>'
"Igual lo deshabilito con esto. Comentar para no deshabilitar:
let g:omni_sql_no_default_maps = 1


" Comandos ------------------------------------------------------------ {{{1
"Para abrir la carpeta actual con Ctrl-F5 {{{2
if has("win32") || has("win32unix")
    if has("gui_running")
        " Open the folder containing the currently open file. Double <CR> at end
        " is so you don't have to hit return after command. Double quotes are
        " not necessary in the 'explorer.exe %:p:h' section.
        :map <silent> <C-F5> :if expand("%:p:h") != ""<CR>:set nossl<CR>:!start explorer.exe %:p:h<CR>:set ssl<CR>:endif<CR><CR>
        :imap <silent> <C-F5> <ESC><C-F5>a
    endif
else
    " Open the folder containing the currently open file. Double <CR> at end
    " is so you don't have to hit return after command. Double quotes are necessary in linux.
    :map <silent> <C-F5> :if expand("%:p:h") != ""<CR>:!dolphin "%:p:h" &<CR>:endif<CR><CR>
    :imap <silent> <C-F5> <ESC><C-F5>a
endif

"Para swapear l√≠neas con Ctrl-[J|K] {{{2
function! MySwapUp()
    if ( line( '.' ) > 1 )
        let cur_col = virtcol(".")
        if ( line( '.' ) == line( '$' ) )
            normal! ddP
        else
            normal! ddkP
        endif
        execute "normal " . cur_col . "|"
    endif
endfunction
function! MySwapDown()
    if ( line( '.' ) < line( '$' ) )
        let cur_col = virtcol(".")
        normal! ddp
        execute "normal " . cur_col . "|"
    endif
endfunction
noremap <silent> <C-K> :call MySwapUp()<CR>
noremap <silent> <C-J> :call MySwapDown()<CR>
function! Up()
    normal! ~
endfunction

"Para swappear palabras con gw  {{{2
nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>

"Para dejar un enter desde el modo normal {{{2
nmap <C-CR> O<ESC>
imap <C-CR> <C-o>O
"Para dejar un enter en la linea anterior con CTRL-]  Util luego de cerrar un brace }.
imap <C-]> <C-o>O


"Para que C-a incremente un n√∫mero en lugar de seleccionar todo (win32) {{{2
if has("win32")
    unmap <C-a>
endif
"Para tener Folding automatico en source files {{{2
"(zR abrir todos, zM cerrar todos, zc cerrar un fold, zf marcar un fold)
"  autocmd BufNewFile,BufRead {*.cpp,*.h,*.c} setlocal foldmethod=indent
autocmd BufNewFile,BufRead {*.cpp,*.h,*.c} setlocal foldmethod=marker fdl=0

"Para editar makefiles sin expandir tabs a espacios {{{2
autocmd BufNewFile,BufRead [mM]akefile* setlocal noexpandtab

"Para quitar los ^M {{{2
command!  QuitarCM  :%s/$//

"Para quitar los espacios al final de l√≠nea {{{2
command! QuitarTrailingSpace  :%s/\s\s*$//

"Para ir al directorio del archivo actual {{{2
"NOTA: Para ver el contenido de estos registros de filename como %:p:h, hay que
"      pas√°rselos a un comando que espere un path. Por eso :echo %:p:h da invalid
"      expression. Entonces Se puede hacer:
"          :echo expand('%:p:h')
"      O pas√°rselo al comando echo de linux con '!':
"          :!echo %:p:h
"NOTA: hacer cd %:h  tambi√©n casi que servir√≠a, aunque %:h da path relativo
"      mientras que %:p:h da path absoluto.
command! SameDir  :cd %:p:h

"Para comentar muchas lineas editando assembler {{{2
command! -range AsmComment :call MakeComment(<line1>, <line2>, ';')
command! -range AsmUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\);/\1/ | :let @/=@w

"Para comentar muchas lineas editando perl, make, configurations {{{2
command! -range Comment :call MakeComment(<line1>, <line2>, '#')
command! -range UnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)#/\1/ | :let @/=@w

"Para comentar muchas lineas editando .vim files {{{2
command! -range VimComment :call MakeComment(<line1>, <line2>, '"')
command! -range VimUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)"/\1/ | :let @/=@w

"Para comentar muchas lineas editando VisualBasic,VBScript files {{{2
command! -range VComment :call MakeComment(<line1>, <line2>, "'")
command! -range VUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)'/\1/ | :let @/=@w

"Para comentar muchas lineas editando C,CPP,H,CS files {{{2
command! -range CComment :call MakeComment(<line1>, <line2>, '\/\/')
command! -range CUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)\/\//\1/ | :let @/=@w

"Para comentar muchas lineas editando C,CPP,H,CS files con //debug: {{{2
command! -range DComment :call MakeComment(<line1>, <line2>, '\/\/debug:')
command! -range DUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)\/\/debug:\?/\1/ | :let @/=@w

"Para comentar muchas lineas editando .S (HP48 SysRPL) files con * asterisco en columna 0: {{{2
command! -range SComment :let @w=@/ | <line1>,<line2>:s/^/*/ | :let @/=@w
command! -range SUnComment :let @w=@/ | <line1>,<line2>:s/^\(\s*\)\*/\1/ | :let @/=@w

"Funcion para crear comentarios indentados {{{2
function! MakeComment(firstLine, lastLine, commentStr)
    "Count min spaces to the left
    let minSpaceCount = 80
    let i = a:firstLine
    let allEmptyLines = 1
    while i <= a:lastLine
        let line = getline(i)
        let j = 0
        let spaceCount = 0
        let emptyLine = 1
        "Count spaces before a non-space character, ignore empty lines.
        while j < strlen(line)
            if line[j] == " " || line[j] == "\t"
                let spaceCount = spaceCount + 1
            else
                let emptyLine = 0
                let allEmptyLines = 0
                break
            endif
            let j = j + 1
        endwhile
        "Determine minimum indentation space count:
        if !emptyLine && spaceCount < minSpaceCount
            let minSpaceCount = spaceCount
        endif
        let i = i + 1
    endwhile

    "Don't create comments if all lines are empty (only space):
    if allEmptyLines
        return
    endif

    "Generate space match string
    let spaceChars = ""
    let i = 0
    while i < minSpaceCount
        let spaceChars = spaceChars . '\s'
        let i = i + 1
    endwhile

    "Insert commentStr after the minimum spaces of indentation:
    exe a:firstLine . ',' . a:lastLine . ':s/^\(' . spaceChars . '\)/\1' . a:commentStr . '/'
endfunction

"Para que el default syntax para los .asm sea NASM {{{2
let asmsyntax="nasm"

"Properties en CSharp a partir de los campos privados {{{2
command! -range MakeProperties <line1>,<line2>:s/^\s*\(private\|protected\) \(.*\) \([^;]*\)[;]/\t\tpublic \2 \u\3\r\t\t{\r\t\t\tget {return \3;}\r\t\t\tset {\3 = value;}\r\t\t}\r/

"Llenado en CSharp de las properties de un objeto {{{2
command! -range MakeObjFromReader <line1>,<line2>:s/.*private \(.*\) \([^;]*\);/\t\t\tobj.\2 = (\1) r\[\"\2\"\];/

"Properties proxy en C# a partir de una interfaz {{{2
"
"Implementa como property un rengl√≥n de interfaz con la forma
"       Tipo NombrePropiedad {get; set;}
"Se lo banca si no tiene el getter o el setter.
command! -range ImplementProxyProperties <line1>,<line2>call ImplementProxyProperties()
function! ImplementProxyProperties() range
    let i = a:firstline
    let lastLine = a:lastline

    while i <= lastLine
        let line = getline(i)

        let property = s:implementProxyPropertyFromString(line)

        call s:insertFromLine(i, property)

        let newlineCount = s:strcount(property, "\n")
        let i = i + newlineCount + 1
        let lastLine = lastLine + newlineCount
        execute "normal :" i
    endwhile
endfunction

"Reemplaza la l√≠nea lineNumber por expr. Si expr es multil√≠nea, inserta las
"siguientes l√≠neas luego sin sobreescribir las que estaban. S√≥lo se pisa la
"primera, la indicada por lineNumber.
"La funci√≥n setline() no sirve porque no permite newlines. Esta funci√≥n s√≠.
function! s:insertFromLine(lineNumber, expr)
    if a:expr != ""
        set paste
        "Ir a la l√≠nea
        execute ":" . a:lineNumber
        "Borrarla
        normal! ddO
        "Escribir
        execute "normal i" . a:expr
        set nopaste
    endif
endfunction

function! s:strcount (haystack, needle)
    let i = 0
    let c = 0
    while i < strlen(a:haystack)
        let i = stridx(a:haystack, a:needle, i)
        if i == -1
            break
        endif
        let c = c + 1
        let i = i + 1
    endwhile
    return c
endfunction

function! s:implementProxyPropertyFromString (line)
    "Capturar el indent, el tipo, el nombre y si tiene getter o setter.

    let list = matchlist(a:line, '^\(\s*\)\(\S*\)\s*\(\S*\)\s*{\(.*\)}\s*$')

    if list == []
        return ""
    endif

    let startSpace = list[1]
    let type = list[2]
    let name = list[3]
    let body = list[4]

    let property = startSpace . "public " . type . " " . name . "\n"
    let property = property . startSpace . "{" . "\n"
    if body =~ "get"
        let property = property . startSpace . "\tget {return proxy." . name . ";}\n"
    endif
    if body =~ "set"
        let property = property. startSpace . "\tset {proxy." . name . " = value;}\n"
    endif
    let property = property . startSpace . "}\n"

    return property
endfunction

"M√©todos proxy en CSharp a partir de una interfaz {{{2
command! -range ImplementProxyMethods <line1>,<line2>call ImplementProxyMethods()
function! ImplementProxyMethods() range
    let i = a:firstline
    let lastLine = a:lastline

    while i <= lastLine
        let line = getline(i)

        let method = s:implementProxyMethodFromString(line)

        call s:insertFromLine(i, method)

        let newlineCount = s:strcount(method, "\n")
        let i = i + newlineCount + 1
        let lastLine = lastLine + newlineCount
        execute "normal :" i
    endwhile
endfunction

function! s:implementProxyMethodFromString (line)
    "Capturar el indent, el tipo, el nombre y si tiene getter o setter.

    let list = matchlist(a:line, '^\(\s*\)\(\S*\)\s*\(\S*\)\s*(\(.*\))\s*;\s*$')

    if list == []
        return ""
    endif

    let startSpace = list[1]
    let type = list[2]
    let name = list[3]
    let body = list[4]

    let paramNamesList = s:parseParamNames(body)

    let method = startSpace . "public " . type . " " . name . "(" . body . ")\n"
    let method = method . startSpace . "{" . "\n"
    let method = method . startSpace . "\t"
    if (type != "void")
        let method = method . "return "
    endif
    let method = method . "proxy." . name . "(" . join(paramNamesList, ", ") . ");\n"
    let method = method . startSpace . "}\n"

    return method
endfunction

"Devuelve una lista con los nombres de par√°metros sin los types ni las comas.
"Lo que debe recibir es la lista de argumentos, sin los par√©ntesis y sin espacios en los bordes.
"Si el type tiene "out" o "ref" como prefijo, se incluir√° en el nombre
"resultante.
function! s:parseParamNames (body)
    let paramNames = []
    let i = 0
    let captureName = '[^,]*\s\([_0-9A-Za-z]*\)\(,\|$\)'
    while i < strlen(a:body)
        let mlist = matchlist(a:body, captureName, i)
        if mlist == []
            break
        endif

        let paramName = mlist[1]

        if mlist[0] =~ '^\s*out\s'
            let paramName = "out " . paramName
        endif
        if mlist[0] =~ '^\s*ref\s'
            let paramName = "ref " . paramName
        endif

        call add(paramNames, paramName)
        let i = i + strlen(mlist[0])
    endwhile
    return paramNames
endfunction

"Generar defininciones de constantes a partir de un String Table Resource {{{2
command! -range MakeHeaderFromResource  <line1>,<line2>call MakeHeaderFromResource()
function! MakeHeaderFromResource() range
    "Reemplaza las columnas de strings por defines con valores incrementales
    let i = a:firstline
    let val = 100
    while i <= a:lastline
        let line = getline(i)
        let repl = substitute(line, '[ ]*\(IDS_[^, ]*\).*', '#define \1\t' . val, 'g')
        call setline(i, repl)
        let i=i+1
        if line != repl
            let val = val + 1
        endif
    endwhile
endfunction

"Folding como en .NET  {{{2
function! NetFold()
  syn region myFold start="#region" end="#endregion" fold transparent
  syn sync fromstart
  set foldmethod=syntax
  set foldcolumn=2
endfunction
function! NetUnFold()
  set foldmethod=manual
  set foldcolumn=0
  norm zE
endfunction
autocmd BufNewFile,BufRead *.cs setfiletype cs
autocmd BufNewFile,BufRead *.cs call NetFold()
command! NetFolding  :call NetFold()
command! UnNetFolding  :call NetUnFold()

"Insertar tiempo en el current buffer {{{2
function! WriteTime()
    call append(line("."), strftime("%X") . "  ")
    .+1
    norm A
endfunction
command! Time :call WriteTime()
"nmap <C-T> :Time<CR>A
"imap <C-T> <ESC>:Time<CR>A

"IfnDef, define y endif para headers c++ {{{2
command! -range MakeIfndef <line1>,<line2> :s/\(.*\)/#ifndef \1\r#define \1\r\r\r#endif \/\/\1\r/

"Arreglar los acentos de un archivo de dir/s {{{2
function! DirsFixFunction()
    "norm :%s/o/√≥/gc<CR>:%s/¬áao/√ß√£o/gc<CR>:%s/¬á/√ß/gc<CR>:%s/¬à/√™/gc<CR>:%s/¬®/¬ø/gc<CR>:%s/¬¢/√≥/gc<CR>:%s/¬Ç/√©/gc<CR>:%s/√∏/¬∞/gc<CR>:%s/¬ê/√â/gc<CR>:%s/¬°/√≠/gc<CR>:%s/¬£/√∫/gc<CR>:%s/¬ï/√≤/gc<CR>:%s/¬†/√°/gc<CR>:%s/¬§/√±/gc<CR>
    exe ":%s/¬áao/√ß√£o/gce"
    exe ":%s/¬á/√ß/gce"
    exe ":%s/¬à/√™/gce"
    exe ":%s/¬®/¬ø/gce"
    exe ":%s/¬¢/√≥/gce"
    exe ":%s/¬Ç/√©/gce"
    exe ":%s/√∏/¬∞/gce"
    exe ":%s/¬ê/√â/gce"
    exe ":%s/¬°/√≠/gce"
    exe ":%s/¬£/√∫/gce"
    exe ":%s/¬ï/√≤/gce"
    exe ":%s/¬†/√°/gce"
    exe ":%s/¬§/√±/gce"
    exe ":%s/¬ô/√ñ/gce"
    exe ":%s/¬î/√∂/gce"
    exe ":%s/¬ì/√¥/gce"
    exe ":%s/¬´/¬Ω/gce"
    exe ":%s/¬ß/¬∫/gce"
    exe ":%s//¬§/gce"
    exe ":%s/¬ä/√®/gce"
    exe ":%s/¬ò/√ø/gce"
    exe ":%s/¬Ñ/√§/gce"
    exe ":%s/¬ã/√Ø/gce"
    exe ":%s/¬É/√¢/gce"
    exe ":%s/¬Å/√º/gce"
    exe ":%s/¬Ö/√†/gce"
    exe ":%s/¬å/√Æ/gce"
endfunction
command! DirsFix :call DirsFixFunction()

"Quitar un Buffer sin cerrar la ventana  {{{2
" Por Raymond Li -----------------------------
" Put this into .vimrc or make it a plugin.
" Mapping :Bclose to some keystroke would probably be more useful.
" I like the way buflisted() behaves, but some may like the behavior
" of other buffer testing functions.

command! Bclose call <SID>BufcloseCloseIt()

function! <SID>BufcloseCloseIt()
    let l:currentBufNum = bufnr("%")
    let l:alternateBufNum = bufnr("#")
    if buflisted(l:alternateBufNum)
        buffer #
    else
        try
            bnext
        catch /^Vim(bnext):E85: There is no listed buffer$/
            "NOTE: bnext produces error when trying to close :Explore if there
            "      are no other buffers (ie: just opened vim).
            execute("bdelete ".l:currentBufNum)
            return
        endtry
    endif
    if bufnr("%") == l:currentBufNum
        new
    endif
    if buflisted(l:currentBufNum)
        execute("bdelete ".l:currentBufNum)
    endif
endfunction

"Otra funci√≥n para quitar un buffer sin cerrar la ventana {{{2
"Tip #165: Deleting a buffer without closing the window
command! -nargs=? -complete=buffer -bang BufClose
    \ :call BufClose(expand('<args>'), expand('<bang>'))

function! BufClose(buffer, bang)
    if a:buffer == ''
        let buffer = bufnr('%')
    else
        let buffer = bufnr(a:buffer)
    endif

    if buffer == -1
        echohl ErrorMsg
        echomsg "No matching buffer for" a:buffer
        echohl None
        return
    endif

    let current_window = winnr()
    let buffer_window = bufwinnr(buffer)

    if buffer_window == -1
        echohl ErrorMsg
        echomsg "Buffer" buffer "isn't open in any windows."
        echohl None
        return
    endif

    if a:bang == '' && getbufvar(buffer, '&modified')
        echohl ErrorMsg
        echomsg 'No write since last change for buffer'
            \ buffer '(add ! to override)'
        echohl None
        return
    endif

    if buffer_window >= 0
        exe 'norm ' . buffer_window . "\<C-w>w"
        exe 'enew' . a:bang
        exe 'norm ' . current_window . "\<C-w>w"
    endif

    silent exe 'bdel' . a:bang . ' ' . buffer
endfunction

"NOTE: Command line for compiling a .NET solution {{{2

" !'C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\msbuild.exe /verbosity:quiet ..\..\ParameterGrid.sln'
"
" !'..\bin\debug\ParameterGridBox.exe'

"NOTE: Regular expression for searching one-line IF's without braces: {{{2
"
"     /\<if\>[^{]*\_$\_.[^{]*$
"
"  Will match:
"       if (hola)
"           printf("hola");
"
"  And not match:
"       if (hola)
"       {
"           printf("hola");
"       }
"
"  Also, replace \<if\> for \<for\> and \<else\> to find those too.
"
"Set cindent on D, JS and HTML files: {{{2

autocmd BufNewFile,BufRead {*.d,*.js,*.html} setlocal cindent

"Set nocindent on TXT files (for commas): {{{2

autocmd BufNewFile,BufRead {*.txt} setlocal nocindent

"Set indent textwidth=92 on to_do.txt for Voom left panel: {{{2
"(Without the Voom outliner left panel it the ideal is tw=123 for GVim):

autocmd BufNewFile,BufRead {to_do*.txt} setlocal tw=92

"NOTE: Shortcut para indentar {{{2
"
"  Seleccionar lo que se quiere indentar y tipear = (igual)
"  Para indentar todo:
"    gg=G
"
"---

"Poner archivo como UTF-8: {{{2

function! Utf8Set()
  set enc=utf-8
  set fenc=utf-8
endfunction

command! Utf8 :call Utf8Set()

"autocmd BufNewFile,BufRead *.php :Utf8

"Funcion para calcular tiempo de sue√±o con DateDiff {{{2

"Calcular las horas de sue√±o dados renglones as√≠:
"            Despert√© 5AM. Antes 2AM. Dorm√≠ 23:30hs.
"            Despert√© 6:30AM. Antes 2:30AM. Dorm√≠ 22hs
"            Despert√© 6:30AM. Dorm√≠ 00hs.
"Para una selecci√≥n, mostrar en output la lista de horas determinada en cada
"uno de esos renglones, o solo un valor si es un rengl√≥n. No altera el buffer.
function! SleepHoursInString(str)
    "Parsear d√≠gitos y ':' luego de las palabras "Despert√©" y "Dorm√≠", sin
    "importar lo de alrededor.
    let m = matchlist(a:str, 'Despert√© \([0-9:]*\).*Dorm√≠ \([0-9:]*\).*')
    if len(m) == 0 || m[1] == "" || m[2] == ""
        return -1
    endif
    let hours = trim(system('DateDiff -t ' . m[1] . ' yesterday ' . m[2]))
    "Restar 24hs a los que se pasan por usar 'yesterday' pero ser luego de medianoche,
    "por ejemplo "DateDiff 8:30 yesterday 1:00 -t" da 31.5 en vez de 7.5.
    let hours = fmod(str2float(hours), 24)
    return hours
endfunction

function! SleepHoursLines(firstLine, lastLine, writeToBuffer)
    "Ir l√≠nea por l√≠nea del range seleccionado y llamar a SleepHoursInString() en cada string de l√≠nea:
    let i = a:firstLine
    let hoursList = []
    while i <= a:lastLine
        let line = getline(i)
        let i = i + 1
        "Parsear cada l√≠nea y ejecutar DateDiff:
        let hours = SleepHoursInString(line)
        if ! a:writeToBuffer
            "Mostrar:
            echon hours . "\n"
        else
            "Guardar:
            call add(hoursList, hours)
        endif
    endwhile

    if a:writeToBuffer
        "Reemplazar esas l√≠neas del buffer con la lista de resultados:
        let i = 0
        while i < len(hoursList)
            call setline(a:firstLine + i, hoursList[i])
            let i = i + 1
        endwhile
    endif
endfunction

command! -range SleepHours :call SleepHoursLines(<line1>, <line2>, 0)
command! -range SleepHoursPut :call SleepHoursLines(<line1>, <line2>, 1)

"--- }}}2

"--- }}}1
